using System;
using System.Collections;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Diagnostics;

namespace Rabies_Model_Core
{
	/// <summary>
	///		An enumeration of animal gender types (just two!!).
	/// </summary>
	public enum enumGender 
	{
		/// <summary>
		///		Female gender.
		/// </summary>
		female,
		/// <summary>
		///		Male gender.
		/// </summary>
		male
	}

	/// <summary>
	///		An enumeration of animal age classes.
	/// </summary>
	public enum enumAgeClass 
	{
		/// <summary>
		///		A young animal dependent on its parent(s).
		/// </summary>
		YoungOfTheYear,
		/// <summary>
		///		A young animal that is independent but is not yet fully adult.
		/// </summary>
		Juvenile,
		/// <summary>
		///		A fully adult animal.
		/// </summary>
		Adult
	}

	/// <summary>
	///		Defines the arguments for the event raised by the animal class when an animal is
	///		infected.
	///	</summary>
	public class cAnimalInfectedEventArgs : EventArgs
	{
		// ********************** Constructor **************************************
		/// <summary>
		///		Initialize.
		/// </summary>
		/// <param name="Animal">
		///		A reference to the animal raising the AnimalInfected event.  An ArgumentNullException
		///		exception is raised in Animal is null.
		/// </param>
		/// <param name="Infection">
		///		A reference to the infection object causing the infection.  An ArgumentNullException
		///		exception is raised in Infection is null.
		/// </param>
		public cAnimalInfectedEventArgs(cAnimal Animal, cInfection Infection) 
		{
			if (Animal == null)
				throw new ArgumentNullException("Animal", "Animal must not be null.");
			if (Infection == null)
				throw new ArgumentNullException("Infection", "Infection must not be null.");
			// set the parameters
			mvarAnimal = Animal;
			mvarInfection = Infection;
		}
		
		// ******************** Properties *****************************************
		/// <summary>
		///		A reference to the animal that raised the event.
		/// </summary>
		public cAnimal Animal
		{
			get 
			{
				return mvarAnimal;
			}
		}

		/// <summary>
		///		A reference to the infection that caused the infection.
		/// </summary>
		public cInfection Infection
		{
			get 
			{
				return mvarInfection;
			}
		}

		// ******************** Private members ************************************
		private cAnimal mvarAnimal;
		private cInfection mvarInfection;
	}

	/// <summary>
	///		Delegate event handler for the AnimalInfected event generated by the
	///		cAnimal	class.
	/// </summary>
	public delegate void AnimalInfectedEventHandler(object sender, cAnimalInfectedEventArgs e);

	/// <summary>
	///		NOTE: This is an abstract class.  You cannot create instances of this class.
	///		This is the base class for all animal types in the rabies model.  As well as
	///		defining basic animal properties, such as age, gender, and current location, this
	///		class provides abstract function templates for the animal's activities as the model
	///		is run.  These activities include reproduction, mortality, movement and other
	///		weekly activities.  This class contains the functionality that calls these activity
	///		functions on a weekly basis in the correct order.  Specific animal types are created
	///		by overriding these abstract function templates in a class derived from this one.
	/// </summary>
	public abstract class cAnimal
	{
		// ******************** constructors ********************************************
		/// <summary>
		///		Construct an animal by specifying its ID, Starting Cell and Background.
		///		This constructor may be used to introduce initial animals into an empty 
		///		background.  All animals created by this constructor come into existance
		///		at year = 0, week = 1.  Although the animals created here will start out
		///		as juveniles, they will have no parents.
		/// </summary>
		/// <param name="ID">
		///		The ID of the animal.  An ArgumentException exception is raised if the ID has
		///		zero length.
		///	</param>
		/// <param name="CellID">
		///		The ID of the cell initially occupied by this animal.  An ArgumentException
		///		exception is raised if the cell is not part of the background object to
		///		which this animal belongs.
		///	</param>
		/// <param name="Background">
		///		The background object in which the animal lives.  An ArgumentNullException
		///		exception is raised if Background is null.
		/// </param>
		/// <param name="Gender">
		///		The gender of the animal.
		/// </param>
		public cAnimal(string ID, string CellID, cBackground Background, enumGender Gender)
		{
			// check all arguments to make sure that they are valid
			// ID must not be zero length.
			if (ID.Length == 0) ThrowIDException();
			// Background must not be null
			if (Background == null) ThrowNullBackgroundException();
			// CellID must be contained in the background master cell list.
			if (!Background.Cells.ContainsKey(CellID))
				throw new ArgumentException("A cell with passed CellID must be part of the passed background.",
					"CellID");
			// construct this animal
			mvarBackground = Background;
			// the ID
			mvarID = ID;
			// the age
			mvarAge = 0;
			// the gender
			mvarGender = Gender;
			// the ID of the animal's parent
			mvarParentID = "-1";
			// the year and week of death
			mvarYearDied = 0;
			mvarWeekDied = 0;
			// the history of cells occupied by this animal
			mvarCells = new cCellTimeList();
			mvarCells.Add(new cCellTime(CellID, 0, 1));
			// create the list of the IDs of all this animal's offspring.
			mvarOffspringIDs = new List<string>();
			// the animal is alive (it was just created!!)
			mvarIsAlive = true;
			// the animal has not dispersed
			mvarIsIndependent = false;            
            // create an infection list
			mvarInfections = new cInfectionList();
			// create a vaccine list
			mvarVaccines = new cVaccineList();
			// add this animal to its first cell
			this.CurrentCell.Animals.Add(this);
			// set marker values to safe defaults
			mvarMarker = "M";
			mvarAutoMarker = "M";
			// give birth flag
			mvarCannotGiveBirth = 0;
			// marker passed by mating partner
			mvarPartnerMarker = "";
            // will die flag //YM
            mvarWillDie = false;
		}

		/// <summary>
		///		Construct an animal by specifying its ID and Parent.  This constructor is
		///		used when giving birth to new animals.  The background, and initial cell 
		///		are obtained from the parent animal.  The year and week of birth are 
		///		obtained from the background that the parent belongs to.
		/// </summary>
		/// <param name="ID">
		///		The ID of the animal.  An ArgumentException exception is raised if the ID has
		///		zero length.
		///	</param>
		/// <param name="Parent">
		///		The parent of the animal.  An ArgumentNullException exception is raised if
		///		Parent is null.
		///	</param>
		/// <param name="Gender">The gender of the animal.</param>
		public cAnimal(string ID, cAnimal Parent, enumGender Gender) 
		{
			// check all arguments to make sure that they are valid.
			// ID must not be zero length.
			if (ID.Length == 0) ThrowIDException();
			// Parent must not be null
			if (Parent == null)
				throw new ArgumentNullException("Parent", "Parent must not be null.");
			// construct this animal
			mvarBackground = Parent.Background;
			// the ID
			mvarID = ID;
			// the age
			mvarAge = 0;
			// the Gender
			mvarGender = Gender;
			// the ID of the animal's parent
			mvarParentID = Parent.ID;
			// the year and week of death
			mvarYearDied = 0;
			mvarWeekDied = 0;
			// set marker values to safe defaults
			mvarMarker = "M";
			mvarAutoMarker = "M";
			// give birth flag
			mvarCannotGiveBirth = 0;
			// marker passed by mating partner
			mvarPartnerMarker = "";
			// the history of cells occupied by this animal
			mvarCells = new cCellTimeList();
			mvarCells.Add(new cCellTime(Parent.CurrentCell.ID, 
				Parent.Background.Years.CurrentYearNum,
				Parent.Background.Years.CurrentYear.CurrentWeek));
			// create the list of the IDs of all this animal's offspring.
			mvarOffspringIDs = new List<string>();
			// the animal is alive (it was just created!!)
			mvarIsAlive = true;
			// the animal has not dispersed
			mvarIsIndependent = false;            
            // create an infection list
            mvarInfections = new cInfectionList();
			// create a vaccine list
			mvarVaccines = new cVaccineList();
			// add this animal to its first cell
			this.CurrentCell.Animals.Add(this);
            // will die flag //YM
            mvarWillDie = false;
        }

		/// <summary>
		///		Construct an animal from a cAnimalAttributes object.  This constructor is
		///		used when loading animal data from a datasource.
		/// </summary>
		/// <param name="Attributes">
		///		The cAnimalAttributes object containing the attributes for the animal.  An
		///		ArgumentNullException exception is raised if Attributes is null.
		/// </param>
		/// <param name="Background">
		///		The background object in which the animal lives.  An ArgumentNullException
		///		exception is raised if Background is null.
		/// </param>
		public cAnimal(cAnimalAttributes Attributes, cBackground Background) 
		{
			// Attributes must not be null
			if (Attributes == null)
				throw new ArgumentNullException("Attributes", "Attributes must not be null.");
			// Background must not be null
			if (Background == null) ThrowNullBackgroundException();
			// read the attributes
			mvarID = Attributes.ID;
			// the ID of the animal's parent
			mvarParentID = Attributes.ParentID;
			// a list of the IDs of the cells occupied by the animal.  Stored with the ID is
			// the time the animal entered that cell.  The last cell in the list is the
			// animal's current cell.
			mvarCells = Attributes.Cells;
			// a list of the IDs of all this animals offspring.
			mvarOffspringIDs = Attributes.Offspring;
			// a reference to this animal's background
			mvarBackground = Background;
			// the gender of this animal
			mvarGender = Attributes.Gender;
			// a boolean flag indicating whether or not this animal is alive.
			mvarIsAlive = Attributes.IsAlive;
			// a boolean flag indicating whether or not this animal has dispersed.
			mvarIsIndependent = Attributes.IsIndependent;           
            // a list of infections that the animal may have
            mvarInfections = Attributes.Infections;
			// create a vaccine list
			mvarVaccines = Attributes.Vaccines;
			// the year the animal died
			mvarYearDied = Attributes.YearDied;
			// the week the animal died
			mvarWeekDied = Attributes.WeekDied;
			// the animal's age
			mvarAge = Attributes.Age;
			// the markers
			if (Attributes.Marker != null)
				mvarMarker = Attributes.Marker;
			else
				mvarMarker = "M";
			if (Attributes.AutoMarker != null)
				mvarAutoMarker = Attributes.AutoMarker;
			else
				mvarAutoMarker = "M";
			// give birth flag
			mvarCannotGiveBirth = Attributes.CannotGiveBirth;
			// marker passed by mating partner
			mvarPartnerMarker = Attributes.PartnerMarker;
			// add this animal to its first cell
			this.CurrentCell.Animals.Add(this);
            // will die flag //YM
            mvarWillDie = false;
        }

		// ******************** properties ***********************************************
		/// <summary>
		///		The ID of the animal object (read-only).
		/// </summary>
		public string ID
		{
			get 
			{
				return mvarID;
			}
		}

		/// <summary>
		///		The gender of the animal object (read-only).
		/// </summary>
		public enumGender Gender
		{
			get 
			{
				return mvarGender;
			}
		}

		/// <summary>
		///		The current age of the animal in weeks (read-only).
		/// </summary>
		public int Age 
		{
			get 
			{
				return mvarAge;
			}
            set
            {
                mvarAge = value;
            }
        }

		/// <summary>
		///		The age class of the animal object (read-only).  Note: you must override
		///		this property in classes derived from cAnimal.
		/// </summary>
		public abstract enumAgeClass AgeClass
		{
			get; 
		}

		/// <summary>
		///		The parent of the animal (read-only).  If the parent is dead and has been
		///		remove the MasterAnimalList of the background, this property is null.
		/// </summary>
		public cAnimal Parent 
		{
			get 
			{
				if (mvarBackground.Animals.ContainsKey(mvarParentID)) {
					return mvarBackground.Animals[mvarParentID];
				}
				else {
					return null;
				}
			}
		}

		/// <summary>
		///		The ID of the parent of this animal (read-only).
		/// </summary>
		public string ParentID 
		{
			get 
			{
				return mvarParentID;
			}
		}

		/// <summary>
		///		The background in which this animal lives (read-only).
		/// </summary>
		public cBackground Background 
		{
			get 
			{
				return mvarBackground;
			}
		}

		/// <summary>
		///		The cell currently occupied by the animal (read-only).
		/// </summary>
		public cCell CurrentCell
		{
			get 
			{
				// the cell of interest is the last cell in the mvarCells list of cells
				return mvarBackground.Cells[mvarCells[mvarCells.Count - 1].CellID];
			}
		}

		/// <summary>
		///		The IDs of the offspring of this animal.
		/// </summary>
		public List<string> Offspring 
		{
			get 
			{
				// create a deep copy of the OffspringID's and return that
				List<string> IDs = new List<string>();
				foreach (string ID in mvarOffspringIDs) {
					IDs.Add(ID);
				}
				// return the deep copy
				return IDs;
			}
		}

		/// <summary>
		///		The year the animal was born (read-only).
		/// </summary>
		public int YearBorn
		{
			get 
			{
				// the desired year is stored as part of the first item in the mvarCells
				// list.
				return mvarCells[0].Year;
			}
		}

		/// <summary>
		///		The week the animal was born (read-only).
		/// </summary>
		public int WeekBorn
		{
			get 
			{
				// the desired week is stored as part of the first item in the mvarCells
				// list.
				return mvarCells[0].Week;
			}
		}

		/// <summary>
		///		The year the animal died (read-only).  An InvalidOperationException exception is
		///		raised if the animal is still alive.
		/// </summary>
		public int YearDied 
		{
			get 
			{
				if (mvarIsAlive) ThrowIsAliveException();
				return mvarYearDied;
			}
		}

		/// <summary>
		///		The week the animal died (read-only).  An InvalidOperationException exception is
		///		raised if the animal is still alive.
		/// </summary>
		public int WeekDied
		{
			get 
			{
				if (mvarIsAlive) ThrowIsAliveException();
				return mvarWeekDied;
			}
		}

		/// <summary>
		///		A flag indicating whether or not the animal is alive (read-only).
		/// </summary>
		public bool IsAlive
		{
			get 
			{
				return mvarIsAlive;
			}
		}

		/// <summary>
		///		A flag indicating whether of not the animal has dispersed (read-only).
		/// </summary>
		public bool IsIndependent 
		{
			get 
			{
				return mvarIsIndependent;
			}
		}

        /// <summary>
        ///		A flag indicating whether or not the animal has a disease (read-only).
        /// </summary>
        public bool HasDisease 
		{
			get
			{
				// no infections?? return false
				if (mvarInfections.Count == 0) return false;
				// there are infections!! have any not run their course??
				int CurrentYear = mvarBackground.Years.CurrentYearNum;
				int CurrentWeek = mvarBackground.Years.CurrentYear.CurrentWeek;
				foreach (cInfection Infection in mvarInfections) {
					if (!Infection.HasRunCourse(CurrentYear, CurrentWeek)) return true;
				}
				// all have run their course.  return false.
				return false;
			}
		}

		/// <summary>
		///		A marker automatically passed from Mother to offspring.
		/// </summary>
		public string AutoMarker
		{
			get
			{
				return mvarAutoMarker;
			}

			set
			{
				mvarAutoMarker = value;
			}
		}

		/// <summary>
		///		A marker that can be passed from Mother (or Father) to offspring.
		/// </summary>
		public string Marker
		{
			get
			{
				return mvarMarker;
			}

			set
			{
				mvarMarker = value;
			}
		}

		/// <summary>
		///		A marker passed to this animal during mating by a mating partner.
		/// </summary>
		public string PartnerMarker
		{            
            get
			{
				return mvarPartnerMarker;
			}

			set 
			{
				mvarPartnerMarker = value;
			}
		}
		/// <summary>
		///		A flag indicating whether or not this animal can give birth (read-only).
		/// </summary>
		public bool CannotGiveBirth
		{
			get 
			{
				return (mvarCannotGiveBirth > 0);
			}
		}

		/// <summary>
		///		Get or set the number of weeks until this animal is able to give birth.
		/// </summary>
		public int CannotGiveBirthValue
		{
			get 
			{
				return mvarCannotGiveBirth;
			}
			set 
			{
				mvarCannotGiveBirth = value;
			}
		}

        /// <summary>
        /// Get or set the index position of this animal when it is first loaded.  Not updated during the
        /// running of the model!!
        /// </summary>
        public int ListIndex
        {
            get
            {
                return mvarListIndex;
            }
            set
            {
                mvarListIndex = value;
            }
        }

        /// <summary>
        /// //YM
        /// Get or set the Reproduction week.
        /// </summary>
        public int ReproductionWeek
        {
            get
            {
                return mvarReproductionWeek;
            }
            set
            {
                mvarReproductionWeek = value;
            }
        }

        /// <summary>
        /// //YM
        /// Get or set the Reproduction week2.
        /// </summary>
        public int ReproductionWeek2
        {
            get
            {
                return mvarReproductionWeek2;
            }
            set
            {
                mvarReproductionWeek2 = value;
            }
        }
        /// <summary>
        /// //YM
        /// Get or set the Reproduction week.
        /// </summary>
        public int ReproductionWeek3
        {
            get
            {
                return mvarReproductionWeek3;
            }
            set
            {
                mvarReproductionWeek3 = value;
            }
        }

        /// <summary>
        /// //YM
        /// Get or set the mating week.
        /// </summary>
        public int MatingWeek
        {
            get
            {
                return mvarMatingWeek;
            }
            set
            {
                mvarMatingWeek = value;
            }
        }

        /// <summary>
        /// //YM
        /// Get or set the mating week.
        /// </summary>
        public int MatingWeek2
        {
            get
            {
                return mvarMatingWeek2;
            }
            set
            {
                mvarMatingWeek2 = value; 
            }
        }
        /// <summary>
        /// //YM
        /// Get or set the mating week.
        /// </summary>
        public int MatingWeek3
        {
            get
            {
                return mvarMatingWeek3;
            }
            set
            {
                mvarMatingWeek3 = value; 
            }
        }

        /// <summary>
        /// // YM
		/// A flag indicating whether or not this animal has mated.
		/// </summary>
		public bool HasMated
        {
            get
            {
                return mvarHasMated;
            }
            set
            {
                mvarHasMated = value;
            }
        }

        /// <summary>
        /// //YM
        ///	A flag indicating that the animal will die in the current week or not
        /// </summary>
        public bool WillDie
        {
            get
            {
                return mvarWillDie;
            }
            set
            {
                mvarWillDie = value;
            }
        }
        // ******************** Methods *************************************************

        /// <summary>
        ///		A list of all past and present infections affecting this animal.
        /// </summary>
        public cInfectionList GetInfections()
		{
			// create a deep copy of the list of Infections and of the infections themselves
			cInfectionList Copy = new cInfectionList();
			foreach (cInfection Infection in mvarInfections) {
				Copy.Add(Infection.Clone());
			}
			// return the copy
			return Copy;
		}

		/// <summary>
		///		A list of past and present vaccines given to this animal.
		/// </summary>
		public cVaccineList GetVaccines()
		{
			// create a deep copy of the list of Infections and of the infections themselves
			cVaccineList Copy = new cVaccineList();
			foreach (cVaccine Vaccine in mvarVaccines) {
				Copy.Add(Vaccine.Clone());
			}
			// return the copy
			return Copy;
		}

		/// <summary>
		///		Get a list of the ID's of all living, dependent offspring (ie. those that
		///		have not yet left mum (and dad)).  This list will contain juveniles.
		/// </summary>
		/// <returns>
		///		A StringCollection containing the IDs of the dependent offspring.
		/// </returns>
		public List<string> GetDependentOffspring() 
		{
			// create the list
			List<string> IDList = new List<string>();
			// loop through all offspring to find only the living, juvenile animals
			foreach (string AnimalID in mvarOffspringIDs) {
				if (mvarBackground.Animals.ContainsKey(AnimalID)) {
					if (mvarBackground.Animals[AnimalID].AgeClass == enumAgeClass.YoungOfTheYear)
						IDList.Add(AnimalID);
				}
			}
			// return the juveniles in that list.
			return IDList;
		}

		/// <summary>
		///		Get a list of the ID's of all living non-dependent offspring (ie. those that
		///		no longer depend on mum (and dad)).  This list will contain yearlings and
		///		adults.
		/// </summary>
		/// <returns>
		///		A StringCollection containing the IDs of the independent offspring.
		/// </returns>
		public List<string> GetIndependentOffspring() 
		{
			// create the list
			List<string> IDList = new List<string>();
			// loop through all offspring to find only the living, non-juvenile animals
			foreach (string AnimalID in mvarOffspringIDs) {
				if (mvarBackground.Animals.ContainsKey(AnimalID)) {
					if (mvarBackground.Animals[AnimalID].AgeClass != enumAgeClass.YoungOfTheYear)
						IDList.Add(AnimalID);
				}
			}
			// return the non-juveniles in that list.
			return IDList;
		}

		/// <summary>
		///		Get a list of all cells currently and previously occupied by this animal.
		/// </summary>
		/// <returns>
		///		A cCellList containing all the cells the animal has occupied in the order
		///		in which they were occupied.  If a cell was occupied and then later reoccupied,
		///		it will appear several times in this list.
		/// </returns>
		public cCellList GetCellsOccupied()
		{
			// create a new cCellList
			cCellList OccupiedCells = new cCellList(null);
			// all occupied cell IDs are stored in the mvarCells list.  Iterate through
			// this list and add the actual cells to the OccupiedCells list.
			foreach (cCellTime CT in mvarCells) {
				OccupiedCells.Add(mvarBackground.Cells[CT.CellID]);
			}
			return OccupiedCells;
		}

		/// <summary>
		///		Get a list of the IDs of all the cells occupied and the times that each
		///		cell was entered.
		/// </summary>
		/// <returns>
		///		A cCellTimeList list of the cells occupied and and the times that they were
		///		occupied.  If the animal occupied a cell more than once, that cell's ID will
		///		appear several times in the returned list.
		///</returns>
		public cCellTimeList GetCellsAndTime() 
		{
			return mvarCells.Clone();
		}

		/// <summary>
		///		Vaccinate this animal against a disease.
		/// </summary>
		/// <param name="DiseaseName">
		///		The name of the disease that the vaccine will protect against.
		///	</param>
		/// <param name="EffectivePeriod">
		///		The length of time (in weeks) that the vaccine is effective.
		/// </param>
		public void Vaccinate(string DiseaseName, int EffectivePeriod) 
		{
			cVaccine Vaccine = new cVaccine(DiseaseName, mvarBackground.Years.CurrentYearNum,
											mvarBackground.Years.CurrentYear.CurrentWeek, 
											EffectivePeriod);
			mvarVaccines.Add(Vaccine);
		}

        /// <summary>
        ///		Infect the animal with a disease.  If the animal currently has an active
        ///		vaccine against this disease, it will not be infected.  If the animal already
        ///		has this disease, it will not be reinfected.
        /// </summary>
        /// <param name="Disease">
        ///		The disease with which the animal will be infected  An InvalidOperationException
        ///		exception is raised if Disease is not found in the disease collection of the
        ///		background object which this animal occupies.
        /// </param>
        /// <param name="InfectingAnimal">
        ///		The animal casuing the infection.  This can be a null value
        /// </param>
        /// ///EER:<param name="NoIncubation">
        ///		If set to true, the infected animal will be immediately infectious
        /// </param>
        /// ///EER:<param name="NaturalImmunity">
        ///		a string indicating infection history: Never_infected, Infected_died, Infected_recovered 
        /// </param>
        public void Infect(cDisease Disease, cAnimal InfectingAnimal)         
        {
            Infect(Disease, InfectingAnimal, false);             
        }

        /// <summary>
        ///		Infect the animal with a disease.  If the animal currently has an active
        ///		vaccine against this disease, it will not be infected.  If the animal already
        ///		has this disease, it will not be reinfected.
        /// </summary>
        /// <param name="Disease">
        ///		The disease with which the animal will be infected  An InvalidOperationException
        ///		exception is raised if Disease is not found in the disease collection of the
        ///		background object which this animal occupies.
        /// </param>
        /// <param name="InfectingAnimal">
        ///		The animal casuing the infection.  This can be a null value
        /// </param>
        /// <param name="NoIncubation">
        ///		If set to true, the infected animal will be immediately infectious
        /// </param> 
        /// <param name="NaturalImmunity">
        ///		EER: a string indicating infection history: Never_infected, Infected_died, Infected_recovered
        /// </param>
        ///
        public void Infect(cDisease Disease, cAnimal InfectingAnimal, bool NoIncubation) 
		{
			int CurrentYear = mvarBackground.Years.CurrentYearNum;
			int CurrentWeek = mvarBackground.Years.CurrentYear.CurrentWeek;
			// the disease must be in the background that the animal lives in.  If it is not,
			// throw an exception.
			bool Found = false;
			foreach (cDisease D in mvarBackground.Diseases) 
			{
				if (D == Disease) {
					Found = true;
					break;
				}
			}
			if (!Found)
				throw new InvalidOperationException("Must infect an animal with a disease in its background object.");
            // does this animal have vaccine protection against this disease
			foreach (cVaccine Vaccine in mvarVaccines) {
				// does this vaccine protect against this disease
				if (Disease.Name == Vaccine.DiseaseName) 
				{
					// yes!! Is the vaccine still effective.  If so, leave now
					if (Vaccine.IsEffective(mvarBackground.Years.CurrentYearNum, mvarBackground.Years.CurrentYear.CurrentWeek)) return;
				}
			}
			// does this animal already have an active infection of this disease
			foreach (cInfection Infection in mvarInfections) {
				if (Disease.Name == Infection.Disease.Name) {
                    // if this infection has the same disease name as the intended infection, and is still
                    // running it's course, exit now
                    if (!Infection.HasRunCourse(CurrentYear, CurrentWeek)) return;
                    // is the animal immune from this disease
                    if (Infection.Disease.BecomesImmune) return;
                    //EER:
                    //if (Infection.Disease.BecomesImmune)
                    //{                        
                    //    Infection.NaturalImmunity = "Infected_recovered";
                    //    return;
                    //}                    
				}
			}
			// add an infection to the animal's infection list
			cInfection NewInfection;
			if (InfectingAnimal == null)   // this is a 'seed' infection
				NewInfection = new cInfection(mvarBackground, Disease.Name, CurrentYear,
					CurrentWeek, "", NoIncubation);
			else   // this is an infection passed from another animal
				NewInfection = new cInfection(mvarBackground, Disease.Name, CurrentYear,
					CurrentWeek, InfectingAnimal.ID, NoIncubation);
			mvarInfections.Add(NewInfection);
			// raise the AnimalInfected event
			RaiseAnimalInfected(NewInfection);
		}

        /// <summary>
        ///  YM :
        ///		This function is used to determine the reproduction week.
        ///		It is a probability function distribution value
        ///     assuming a Gaussian distribution, where the Mean and the Variance were given by the user.
        /// </summary>
        /// <returns> The value of the reproduction week.</returns>
        public abstract int ComputeReproductionWeekGaussian();

        ///  YM :
        ///		This function is used to determine the reproduction week.
        ///		It is a probability function distribution value
        ///     assuming a Gaussian distribution, where the Mean and the Variance were given by the user.
        /// </summary>
        /// <returns> The value of the reproduction week.</returns>
        public abstract int ComputeReproductionWeekGaussian2();
        /// <summary>
        ///  YM :
        ///		This function is used to determine the reproduction week.
        ///		It is a probability function distribution value
        ///     assuming a Gaussian distribution, where the Mean and the Variance were given by the user.
        /// </summary>
        /// <returns> The value of the reproduction week.</returns>
        public abstract int ComputeReproductionWeekGaussian3();

        /// <summary>
        ///  YM :
        ///		This function is used to determine the mating week.
        ///		It is calculated with the reproduction week values generated with a gaussian distribution and the number of week	
        /// </summary>
        /// <param name="ReproductionWeek">
        ///     The reproduction week.
        /// </param>
        /// <returns> The value of the Mating week.</returns>
        public abstract int ComputeMatingWeek(int ReproductionWeek);

        /// <summary>
        ///		Increment the age of the animal by one week and perform all weekly activities
        ///		(ie. Move, GiveBirth, Mortality etc.).  This function calls all of the specific
        ///		animal activity functions defined in derived animal classes.  
        /// </summary>
        /// <param name="CurrentWeek">
        ///		The current week of the year.  An ArgumentOutOfRangeException exception is
        ///		raised if the value of CurrentWeek is not betwen 1 and 52.
        ///	</param>
        public void DoWeeklyActivities(int CurrentWeek, bool PreventIncest) 
		{
            // throw an exception if current week is not in the range 1-52.
            if (CurrentWeek < 1 || CurrentWeek > 52)
				throw new ArgumentOutOfRangeException("CurrentWeek",
								"Current week must be between 1 and 52.");

            // Calculate the reproduction and mating weeks for each animal
            if(CurrentWeek == 1 && this.Gender == enumGender.female && this.AgeClass != enumAgeClass.YoungOfTheYear)
            {
                ReproductionWeek = ComputeReproductionWeekGaussian();
                ReproductionWeek2 = ComputeReproductionWeekGaussian2();
                ReproductionWeek3 = ComputeReproductionWeekGaussian3();
                MatingWeek = ComputeMatingWeek(ReproductionWeek);
                MatingWeek2 = ComputeMatingWeek(ReproductionWeek2);
                MatingWeek3 = ComputeMatingWeek(ReproductionWeek3);
            }
            

            // if the animal somehow died before this function was called, leave now.
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: DoWeeklyActivities() mvarIsAlive = " + mvarIsAlive);
            if (!mvarIsAlive) return;

            // increment the animal's age
            mvarAge++;

            // check disease status first.  If the animal is infectious, do no more.
            if (this.HandleDisease()) return;

            //stopwatch.Stop();
            //Console.WriteLine("HandleDisease : Time elapsed: {0}", stopwatch.Elapsed); 

            // next handle mortality.           
            if (mvarID == "0") {
                // EER: Eve will always live to be the maximum age
                if (this.mvarAge > getMaxAgeFemale()) Die();
            }
            if (mvarID == "1")
            {
                // EER: Adam will always live to be the maximum age
                if (this.mvarAge > getMaxAgeMale()) Die();
            }
            // EER: Use a numeric data type variable to identify animals
            uint adameveCheck = Convert.ToUInt32(mvarID);

            if (adameveCheck > 1)
            {
                // EER: this animal is not Adam or Eve
                //if (this.mvarAge > getMaxAge() || this.Mortality(CurrentWeek)) Die();  //YM
                if (this.Gender == enumGender.female)
                {
                    if (this.mvarAge >= getMaxAgeFemale()) Die();
                }
                else
                {
                    if (this.mvarAge >= getMaxAgeMale()) Die();
                }

            }

            // birth and mating            
           if (this.Gender == enumGender.female)
           {
                if (this.Mate(CurrentWeek))
                {
                    if (this.AgeClass != enumAgeClass.YoungOfTheYear)
                    {
                        this.DoMating(CurrentWeek, PreventIncest);
                    }

                }
                if (this.GiveBirth(CurrentWeek) & this.HasMated)
                {
                    if (!this.CannotGiveBirth)
                    {
                        this.Spawn();
                    }
				}
			}
            // birth control value           
            if (mvarCannotGiveBirth > 0) mvarCannotGiveBirth--;

            // finally handle movement            
            if (!mvarIsIndependent)
                mvarIsIndependent = this.BecomeIndependent(CurrentWeek);
            else
            {
                this.Move(CurrentWeek);
            }

            // mortality
            if (adameveCheck > 1)
            {
                    if (this.Mortality(CurrentWeek))Die();
            }

        }

		/// <summary>
		///		Kill the animal.  This method removes the animal from various animal lists.
		///		You should, therefore, not call this function while iterating through a 
		///		cAnimalList object.
		/// </summary>
		public void Die() 
		{
            //System.Diagnostics.Debug.WriteLine("");
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: Die()");

            // if the animal is already dead, go no further
            if (mvarIsAlive) {
				// animal is no longer alive
				mvarIsAlive = false;
                // remove this animal from its cell
                this.CurrentCell.Animals.Remove(this.ID);

                // set the year died and week died properties
                mvarYearDied = this.Background.Years.CurrentYearNum;
				mvarWeekDied = this.Background.Years.CurrentYear.CurrentWeek;
                // dependent offspring also die
                // EER: let's make an exception for Eve, so the seed population is more likely to start growing;
                if (this.ID != "0")
                {                    
                    List <string> MyOffSpring = this.Offspring;
                    if (MyOffSpring.Count > 0)
                    {                        
                        for (int i = 0; i < MyOffSpring.Count; i++)
                        {
                            // EER: check if the offspring has a "key"
                            // EER: I think the "key" are identifying all dependent offspring
                            // EER:  note that some offspring may not disperse in their first fall, and remain dependent,
                            // EER:  thus, still have a key, but are old enough to survive by not being considered dependent 
                            if (this.Background.Animals.ContainsKey(MyOffSpring[i]))
                            {
                                cAnimal a = this.Background.Animals[MyOffSpring[i]];
                                if (!a.IsIndependent)
                                {
                                    a.Die();                                   
                                }                                
                            }
                        }
                    }
                }
			}

		}

		/// <summary>
		///		Return the attributes of this animal in an AnimalAttributes object.
		/// </summary>
		/// <param name="Attributes">
		///		The animal attributes object that will contain the attributes.  An
		///		ArgumentNullException exception is raised if Attributes is null.
		/// </param>
		public virtual void GetAttributes(cAnimalAttributes Attributes)
		{
            //System.Diagnostics.Debug.WriteLine("");
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: GetAttributes()");

            // raise an exception if Attributes is null
            if (Attributes == null)
				throw new ArgumentNullException("Attributes", "Attributes cannot be null.");
			// copy attributes to passed attributes object
			Attributes.ID = mvarID;
			Attributes.Age = mvarAge;
			Attributes.YearDied = mvarYearDied;
			Attributes.WeekDied = mvarWeekDied;
			Attributes.Gender = mvarGender;
			Attributes.ParentID = mvarParentID;
			Attributes.IsIndependent = mvarIsIndependent;
			Attributes.IsAlive = mvarIsAlive;            
			Attributes.Offspring = mvarOffspringIDs;
			Attributes.Cells = mvarCells;
			Attributes.Infections = mvarInfections;
			Attributes.Vaccines = mvarVaccines;
			Attributes.AutoMarker = mvarAutoMarker;
			Attributes.Marker = mvarMarker;
			Attributes.CannotGiveBirth = mvarCannotGiveBirth;
		}

        // ************************* equality functions **********************************
        /// <summary>
        ///     Value compare this animal with an object of unspecified type 
        /// </summary>
        /// <param name="obj">The object to compare to</param>
        /// <returns>True if the obj is equal to this animal, false otherwise</returns>
        public override bool Equals(object obj)
        {
            // return result of main equals function
            return Equals(obj as cAnimal);
        }

        /// <summary>
        ///     Value compare this animal with an object of the cAnimal type 
        /// </summary>
        /// <param name="obj">The cAnimal object to compare to</param>
        /// <returns>True if the obj is equal to this animal, false otherwise</returns>
        public virtual bool Equals(cAnimal obj)
        {
            // obj not set? - then return false
            if (obj == null) return false;

            // not the same type of animal? - then obviously not equal
            if (!this.GetType().IsAssignableFrom(obj.GetType())) return false;
            cAnimal objAnimal = obj as cAnimal;

            // compare ID
            if (objAnimal.ID != this.ID) return false;

            // compare gender
            if (objAnimal.Gender != this.Gender) return false;

            // compare age
            if (objAnimal.Age != this.Age) return false;

            // compare parent
            if (objAnimal.ParentID != this.ParentID) return false;

            // compare markers
            if (objAnimal.AutoMarker != this.AutoMarker) return false;
            if (objAnimal.Marker != this.Marker) return false;

            // compare cells occupied
            cCellTimeList objCells = objAnimal.mvarCells;
            cCellTimeList myCells = this.mvarCells;
            if (objCells.Count != myCells.Count) return false;
            for (int i = 0; i < myCells.Count; i++)
            {
                if (objCells[i].CellID != myCells[i].CellID) return false;
                if (objCells[i].Year != myCells[i].Year) return false;
                if (objCells[i].Week != myCells[i].Week) return false;
            }

            // compare current infections
            cInfectionList objInfections = objAnimal.mvarInfections;
            cInfectionList myInfections = this.mvarInfections;
            if (objInfections.Count != myInfections.Count) return false;
            for (int i = 0; i < myInfections.Count; i++)
            {
                if (objInfections[i].Disease.Name != myInfections[i].Disease.Name) return false;
                if (objInfections[i].Year != myInfections[i].Year) return false;
                if (objInfections[i].Week != myInfections[i].Week) return false;
                if (objInfections[i].IncubationPeriod != myInfections[i].IncubationPeriod) return false;
                if (objInfections[i].InfectiousPeriod != myInfections[i].InfectiousPeriod) return false;                
            }

            // compare current vaccinations
            cVaccineList objVaccines = objAnimal.mvarVaccines;
            cVaccineList myVaccines = objAnimal.mvarVaccines;
            if (objVaccines.Count != myVaccines.Count) return false;
            for (int i = 0; i < myVaccines.Count; i++)
            {
                if (objVaccines[i].DiseaseName != myVaccines[i].DiseaseName) return false;
                if (objVaccines[i].EffectivePeriod != myVaccines[i].EffectivePeriod) return false;
                if (objVaccines[i].Year != myVaccines[i].Year) return false;
                if (objVaccines[i].Week != myVaccines[i].Week) return false;
            }
            // if we get here, we have equality
            return true;
        }

        /// <summary>
        /// Get the hashcode for this object
        /// </summary>
        /// <returns>The hashcode</returns>
        public override int GetHashCode()
        {
            // return base value - this is just to stop the compiler from bitching
            return base.GetHashCode();
        }

        // ******************** To string function **************************************

        /// <summary>
        /// Get the string representing this object
        /// </summary>
        /// <returns>The string representing this object</returns>
        public override string ToString()
        {
            return string.Format("{0} (ID: {1}, Gender: {2}, Age: {3})", this.getAnimalDescription(), this.ID, this.Gender.ToString(), this.Age);
        }
        
       

        // *************************** Protected functions ******************************
        /// <summary>
        ///		The function defining the mortality of the animal.  This function SHOULD
        ///		NOT include mortality due to any specifically defined disease.  This 
        ///		function is called once a week, thus each week, an animal has a certain
        ///		chance to die.  NOTE: you must override this function in any class derived
        ///		from cAnimal.
        /// </summary>
        /// <param name="CurrentWeek">The current week of the year.</param>
        /// <returns>True if the animal dies.</returns>
protected abstract bool Mortality(int CurrentWeek);

		/// <summary>
		///		A function called every week in the model.  It determines whether or not
		///		an animal should give birth that week.  NOTE: you must override this
		///		function in any class derived from cAnimal.
		/// </summary>
		/// <param name="CurrentWeek">The current week of the year.</param>
		/// <returns>True if the animal is to give birth that week.</returns>
		protected abstract bool GiveBirth(int CurrentWeek);

        /// <summary>
        ///		A function called every week in the model.  It determines whether or not
        ///		an animal should mate that week.  NOTE: you must override this
        ///		function in any class derived from cAnimal if you require mating in your
        ///		model.
        /// </summary>
        /// <param name="CurrentWeek">The current week of the year.</param>
        /// <returns>True if the animal is to mate that week.</returns>
        protected virtual bool Mate(int CurrentWeek)
		{
			return false;
		}
		/// <summary>
		///		Determine the number of babies a mother is to give birth to.  This
		///		function is called as part of the process of giving birth.  Note: you
		///		must override this function in any class derived from cAnimal.
		/// </summary>
		/// <returns>The number of babies the animal will give birth to.</returns>
		protected abstract int GetNBabies() ;
		
		/// <summary>
		///		Create a new animal as a baby with the passed ID.  The baby must have
		///		this animal as a parent.  Note: you must override this function in any
		///		class derived from cAnimal.  The animal created must be of the type of
		///		the derived class.
		/// </summary>
		/// <param name="ID">The ID that must be assigned to the new animal.</param>
		/// <returns>A reference to the new animal as a cAnimal object.</returns>
		protected abstract cAnimal CreateBaby(string ID);

		/// <summary>
		///		A function called once a week while the animal is dependent.  Use this
		///		function to define behaviour when the animal becomes independent and to
		///		indicate whether or not the animal has become independent.  To actually
		///		move the animal, call the MoveAnimal method of this class.  Call the 
		///		calculatePath method of the master cell list of the background object that
		///		owns the animal to find paths through the cells.  Once an animal becomes
		///		independent, the animal's IsIndependent flag is set true and this function is
		///		not called again.  NOTE: you must override this function in any class derived
		///		from cAnimal.
		/// </summary>
		/// <param name="CurrentWeek">The current week of the year.</param>
		/// <returns>True if the animal becomes independent.</returns>
		protected abstract bool BecomeIndependent(int CurrentWeek);

		/// <summary>
		///		A function called once a week once an animal has become independent.  Use
		///		this function to define movement behaviour of juvenile and adult animals.
		///		To actually move the animal, call the MoveAnimal method of this class.
		///		Call the calculatePath method of the master cell list of the background
		///		object that owns the animal to find paths through the cells.
		///		NOTE: you must override this function in any class derived from cAnimal.
		/// </summary>
		/// <param name="CurrentWeek">The current week of the year.</param>
		/// <returns>True if the animal moves.</returns>
		protected abstract bool Move(int CurrentWeek);

		/// <summary>
		///		Detirmine a contact probability for the animal either in its own cell or to
		///		all of its neighbouring cells given an overall contact rate and the current week.
		///		NOTE: you must override this function in any class derived from cAnimal.
		/// </summary>
		/// <param name="CurrentWeek">The current week of the year.</param>
		/// <param name="Gender"> The Gender of the animal making contact.</param>
		/// <param name="InCell">
		///		True if the contact rate is for within the cell, False if it is for neighbouring cells.
		/// </param>
		/// <param name="OverAllContactRate">The overall odds of contact with a single animal.</param>
		/// <returns>The contact rate either in the cell or with all neighbours.</returns>
		protected abstract double getCellContactRate(int CurrentWeek, enumGender Gender, bool InCell, double OverAllContactRate);

		/// <summary>
		///		Get the maximum age that this animal can live to
		/// </summary>
		/// <returns>The maximum age in weeks</returns>
		protected abstract int getMaxAge();

        /// <summary>
		///		Get the maximum age that this animal can live to
        ///		EER: added so that animals do not live beyond yearly mortality rates of 100%
        ///		EER: and so that max age can differ among sex
		/// </summary>
		/// <returns>The maximum age in weeks</returns>
		protected abstract int getMaxAgeFemale();

        /// <summary>
		///		Get the maximum age that this animal can live to
        ///		EER: added so that animals do not live beyond yearly mortality rates of 100%
        ///		EER: and so that max age can differ among sex
		/// </summary>
		/// <returns>The maximum age in weeks</returns>
		protected abstract int getMaxAgeMale();

        /// <summary>
        ///     Get a description of the type of the animal
        /// </summary>
        /// <returns>A description of the type of the animal</returns>
        protected abstract string getAnimalDescription();

		/// <summary>
		///		A function to handle any disease the animal may have.  This function
		///		performs two operations.  If the animal currently has a disease in its
		///		infectious stage, this function handles the potential spread of that
		///		disease to other animals in the cell and in the neighbouring cells of the
		///		cell occupied by this animal.  If the disease has run its course, this
		///		function will determine whether or not the disease is fatal. If it is, the
		///		animal will die.  This function may be overridden in a class derived from
		///		cAnimal to provided different disease handling and spreading functionality.
		/// </summary>
		/// <returns>
		///		True if a disease is currently infectious. NOTE it is assumed that the animal
		///		does not do its normal behaviour if it is currently influenced by an infectious
		///		disease.
		///	</returns>
		protected virtual bool HandleDisease()
		{
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: HandleDisease()");

            // the return value
            bool RetValue = false;
			// are there any infections?
			if (mvarInfections.Count > 0) {
				// get the current year and week
				int CurrentYear = mvarBackground.Years.CurrentYearNum;
				int CurrentWeek = mvarBackground.Years.CurrentYear.CurrentWeek;
                //System.Diagnostics.Debug.WriteLine("cAnimal.cs: HandleDisease() HERE 01");
                // loop through all infections
                foreach (cInfection Infection in mvarInfections) {
                    //System.Diagnostics.Debug.WriteLine("    cAnimal.cs: HandleDisease(): Infection.InfectingAnimalID = " + Infection.InfectingAnimalID);
                    //System.Diagnostics.Debug.WriteLine("    cAnimal.cs: HandleDisease(): Infection.IncubationPeriod = " + Infection.IncubationPeriod);
                    //System.Diagnostics.Debug.WriteLine("    cAnimal.cs: HandleDisease(): Infection.InfectiousPeriod = " + Infection.InfectiousPeriod);
                    
                    // has the infection run its course
                    if (Infection.HasRunCourse(CurrentYear, CurrentWeek)) {
                        //System.Diagnostics.Debug.WriteLine("cAnimal.cs: HandleDisease() HERE 03");
                        // infection has run its course.  see if it is fatal
                        if (Infection.IsFatal) Die();                        
                    }
					// is the disease infectious
					else if (Infection.IsInfectious(CurrentYear, CurrentWeek)) {
                        //System.Diagnostics.Debug.WriteLine("cAnimal.cs: HandleDisease(): Animal is infectious at year and week = " + CurrentYear + ", " + CurrentWeek);
                        // infectious period occurs if the diesease will be fatal or if recovered animals become infectious anyway
                        if (Infection.IsFatal || !Infection.Disease.RecoveredNotInfectious)
                        {
                            // make return value true
                            RetValue = true;
                            // spread the disease
                            // get the cell occupied by this animal
                            cCell MyCell = this.CurrentCell;
                            // loop through all animals in this cell
                            foreach (cAnimal Animal in MyCell.Animals)
                            {
                                // animal cannot spread disease to itself
                                if (Animal != this)
                                {
                                    // calculate contact rate within the cell
                                    double CellContactRate = this.getCellContactRate(CurrentWeek, mvarGender, true, Infection.Disease.ContactRate);
                                    // does the disease spread?
                                    if (mvarBackground.RandomNum.RealValue(0, 100) < CellContactRate)
                                    {
                                        // YES
                                        Animal.Infect(Infection.Disease, this);                                        
                                    }
                                }
                            }
                            // now consider each of the neighbouring cells
                            List<cCell> CellsToInfect = new List<cCell>();
                            double InfectProbability;
                            // now check each cell in turn
                            if (CanSpreadDiseaseToNeighbour(MyCell.GetNeighbour(enumNeighbourPosition.Top)))
                            {
                                CellsToInfect.Add(MyCell.GetNeighbour(enumNeighbourPosition.Top));
                            }
                            if (CanSpreadDiseaseToNeighbour(MyCell.GetNeighbour(enumNeighbourPosition.TopRight)))
                            {
                                CellsToInfect.Add(MyCell.GetNeighbour(enumNeighbourPosition.TopRight));
                            }
                            if (CanSpreadDiseaseToNeighbour(MyCell.GetNeighbour(enumNeighbourPosition.BottomRight)))
                            {
                                CellsToInfect.Add(MyCell.GetNeighbour(enumNeighbourPosition.BottomRight));
                            }
                            if (CanSpreadDiseaseToNeighbour(MyCell.GetNeighbour(enumNeighbourPosition.Bottom)))
                            {
                                CellsToInfect.Add(MyCell.GetNeighbour(enumNeighbourPosition.Bottom));
                            }
                            if (CanSpreadDiseaseToNeighbour(MyCell.GetNeighbour(enumNeighbourPosition.BottomLeft)))
                            {
                                CellsToInfect.Add(MyCell.GetNeighbour(enumNeighbourPosition.BottomLeft));
                            }
                            if (CanSpreadDiseaseToNeighbour(MyCell.GetNeighbour(enumNeighbourPosition.TopLeft)))
                            {
                                CellsToInfect.Add(MyCell.GetNeighbour(enumNeighbourPosition.TopLeft));
                            }
                            // now calculate the spread probability
                            if (CellsToInfect.Count > 0)
                            {
                                // calculate contact rate
                                double NeighbourContactRate = this.getCellContactRate(CurrentWeek, mvarGender, false, Infection.Disease.ContactRate);
                                if (mvarBackground.UseReflectiveDiseaseSpread)
                                {
                                    // reflective spread - divide by number of "live" neighbours
                                    InfectProbability = NeighbourContactRate / CellsToInfect.Count;
                                }
                                else
                                {
                                    // non-reflective spread - always divide by 6 even if some neighbours are at boundary
                                    InfectProbability = NeighbourContactRate / 6;
                                }
                                // now loop through cells to be infected
                                for (int i = 0; i < CellsToInfect.Count; i++)
                                {
                                    SpreadDiseaseToNeighbour((cCell)CellsToInfect[i], Infection.Disease, InfectProbability);
                                }
                            }
                        }
					}
				}
			}
			return RetValue;
		}

		/// <summary>
		///		Move the animal out of its current cell to the passed cell.
		/// </summary>
		/// <param name="NewCell">
		///		The cell the animal is moving to.  An ArgumentNullException exception is
		///		raised if NewCell is null.  An ArgumentException exception is raised if this
		///		cell is not part of the animal's background.
		///	</param>
		protected void MoveAnimal(cCell NewCell) 
		{
			// throw an exception if NewCell is null
			if (NewCell == null)
				throw new ArgumentNullException("NewCell", "NewCell cannot be null.");
			// throw an exception if this cell is not part of the animal's background
			if (!mvarBackground.Cells.ContainsKey(NewCell.ID))
				throw new ArgumentException("This cell is not part of the animal's background object.",
											"NewCell");
			// if this is animal 0 or 1, do not move no matter what
			if (mvarID == "0" || mvarID == "1") return;
			// first remove this animal from its current cell
			this.CurrentCell.Animals.Remove(mvarID);
			// get the current year and week
			int CurrentYear = mvarBackground.Years.CurrentYearNum;
			int CurrentWeek = mvarBackground.Years.CurrentYear.CurrentWeek;
			// now add the new cell to the top of the cell time list
			mvarCells.Add(new cCellTime(NewCell.ID, CurrentYear, CurrentWeek));
			// now put this animal into its new cell
			this.CurrentCell.Animals.Add(this);
		}

		/// <summary>
		///		Finds a male mate for this animal.  This function provides a
		///		promiscuous mating system.  You may override this function
		///		for other mating systems.
		/// </summary>
		/// <returns>The animal to be this animal's mate.  Null if a mate is not found.</returns>
		protected virtual cAnimal FindMate(int CurrentWeek, bool PreventIncest) 
		{
            //System.Diagnostics.Debug.WriteLine("");
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: FindMate()");

            // this is a two step process.  
            // First decide where the mate will come from
            List<cCell> CellsToMate = new List<cCell>();
			// add this animal's cell to the list
			CellsToMate.Add(this.CurrentCell);
			// consider each of the neighbouring cells
			cCell MyCell = this.CurrentCell;
			// get a list of possible neighbours
			if (MyCell.GetNeighbour(enumNeighbourPosition.Top) != null) 
				CellsToMate.Add(MyCell.GetNeighbour(enumNeighbourPosition.Top));
			if (MyCell.GetNeighbour(enumNeighbourPosition.TopRight) != null) 
				CellsToMate.Add(MyCell.GetNeighbour(enumNeighbourPosition.TopRight));
			if (MyCell.GetNeighbour(enumNeighbourPosition.BottomRight) != null) 
				CellsToMate.Add(MyCell.GetNeighbour(enumNeighbourPosition.BottomRight));
			if (MyCell.GetNeighbour(enumNeighbourPosition.Bottom) != null) 
				CellsToMate.Add(MyCell.GetNeighbour(enumNeighbourPosition.Bottom));
			if (MyCell.GetNeighbour(enumNeighbourPosition.BottomLeft) != null) 
				CellsToMate.Add(MyCell.GetNeighbour(enumNeighbourPosition.BottomLeft));
			if (MyCell.GetNeighbour(enumNeighbourPosition.TopLeft) != null) 
				CellsToMate.Add(MyCell.GetNeighbour(enumNeighbourPosition.TopLeft));
			// now calculate the probability of a mate in one of these cells
			double NeighbourMatingProb = 0;
			if (CellsToMate.Count > 1) {
				// calculate the mating probability - note: always reflective
				NeighbourMatingProb = this.getCellContactRate(CurrentWeek, enumGender.male, false, 100) / (CellsToMate.Count - 1);
			}
			// probability of mating in home cell
			double HomeMatingProb = 100.0 - NeighbourMatingProb * (CellsToMate.Count - 1);
			// random number between zero and 100
			double RandomVal = mvarBackground.RandomNum.RealValue(0, 100);
			// loop through list of cells to find desired value
			cCell MatingCell = null;
			for (int i = 0; i < CellsToMate.Count - 1; i++) {
				if (i == 0) {
					if (RandomVal < HomeMatingProb) {
						MatingCell = (cCell) CellsToMate[i];
						break;
					}
				}
				else {
					if (RandomVal < HomeMatingProb + NeighbourMatingProb * i) {
						MatingCell = (cCell) CellsToMate[i];
						break;
					}
				}
			}
			// if no cell was chosen, then the last in the list is it
			if (MatingCell == null) MatingCell = (cCell) CellsToMate[CellsToMate.Count - 1];
			// OK, we have our mating cell, now find a mate from this cell
			cAnimalList PossibleMates = MatingCell.Animals.GetByGender(enumGender.male);
			// if PreventIncest is true, remove any siblings from this list
			// Note: siblings share the same mother
			if (PreventIncest && mvarParentID != "-1") {
				for (int i=PossibleMates.Count - 1; i>=0; i--) {
					if (PossibleMates[i].ParentID == mvarParentID) PossibleMates.RemoveAt(i);
				}
			}
			// pick a single mate from the list of mates
			cAnimal TheMate = null;
			if (PossibleMates.Count > 0) {
				// probability for any one animal
				double AnimalProb = 100.0 / PossibleMates.Count;
				// generate a random number
                RandomVal = mvarBackground.RandomNum.RealValue(0, 100);
				// loop through possible mates to find the one
				for (int i = 1; i < PossibleMates.Count - 1; i++) {
					if (RandomVal < AnimalProb * i) {
						TheMate = PossibleMates[i - 1];
						break;
					}
				}
				// if no animal was chosen, then the last one is it
				if (TheMate == null) TheMate = PossibleMates[PossibleMates.Count - 1];
			}
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: FindMate() END");
            return TheMate;
		}

		/// <summary>
		///		Compare the marker for this animal with that of a second animal.
		///		This function may be overridden.
		/// </summary>
		/// <param name="Other">The animal which is being compared</param>
		/// <returns>True if markers are compatible, false otherwise.</returns>
		protected virtual bool CompareMarkers(cAnimal Other)
		{
            //System.Diagnostics.Debug.WriteLine("");
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: CompareMarkers()");

            // if markers are default value, return true
            if (mvarMarker.ToLower() == "m" && Other.Marker.ToLower() == "m") 
				return true;
			else {
				// if only one is the default, we have a problem
				if (mvarMarker.ToLower() == "m" || Other.Marker.ToLower() == "m") return false;
			}
			// create arrays of markers
			GeneticMarker[] MyMarkers = RetrieveMarkers(mvarMarker);
			GeneticMarker[] OtherMarkers = RetrieveMarkers(Other.Marker);
			// to be compatible, there should be the same number of items
			if (MyMarkers.Length != OtherMarkers.Length) return false;
			// now compare marker names
			for (int i=0; i<MyMarkers.Length; i++) {
				GeneticMarker a = MyMarkers[i];
				GeneticMarker b = OtherMarkers[i];
				if (a.Name.ToLower() != b.Name.ToLower()) return false;
			}
			// all checks out
			return true;
		}

		// calculate a new marker for a baby animal
		protected virtual string CalculateMarker() {
            //System.Diagnostics.Debug.WriteLine("");
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: CalculateMarker(): new marker for a baby animal");
            
            // if both markers are the default, return the default
			if (mvarMarker.ToLower() == "m" && mvarPartnerMarker.ToLower() == "m") return "M";
			// now get marker lists for both parents
			GeneticMarker[] MomMarkers = RetrieveMarkers(mvarMarker);
			GeneticMarker[] DadMarkers = RetrieveMarkers(mvarPartnerMarker);
			// now calculate markers for baby
			StringBuilder BabyMarkers = new StringBuilder();
			// random number generator
			for (int i=0; i<MomMarkers.Length; i++) {
				if (i > 0) BabyMarkers.Append(";");
				GeneticMarker a = MomMarkers[i];
				GeneticMarker b = DadMarkers[i];
				// name
				BabyMarkers.AppendFormat("{0}:", a.Name);
				// Mom
				if (mvarBackground.RandomNum.IntValue(1, 100) <= 50) 
					BabyMarkers.AppendFormat("{0}:", a.Value1);
				else
					BabyMarkers.AppendFormat("{0}:", a.Value2);
				// Dad
				if (mvarBackground.RandomNum.IntValue(1, 100) <= 50) 
					BabyMarkers.Append(b.Value1);
				else
					BabyMarkers.Append(b.Value2);
			}
			// return the new marker
			return BabyMarkers.ToString();
		}

		// ******************** internal functions **************************************
		/// <summary>
		///		Set the IsIndependent flag.  This is an internal function that can only be
		///		called by classes within the Rabies_Model_Core namespace.
		/// </summary>
		/// <param name="Value">The value to set the IsIndependent flag to.</param>
		internal void SetIsIndependent(bool Value)
		{
			mvarIsIndependent = Value;
		}

		// ******************** private members *****************************************
		// the ID of the animal
		private string mvarID;
		// the ID of the animal's parent
		private string mvarParentID;
		// the animal's age
		private int mvarAge;
		// a list of the IDs of the cells occupied by the animal.  Stored with the ID is
		// the time the animal entered that cell.  The last cell in the list is the
		// animal's current cell.
		private cCellTimeList mvarCells;
		// a list of the IDs of all this animals offspring.
		private List<string> mvarOffspringIDs;
		// a reference to this animal's background
		private cBackground mvarBackground;
		// the gender of this animal
		private enumGender mvarGender;
		// a boolean flag indicating whether or not this animal is alive.
		private bool mvarIsAlive;
		// a boolean flag indicating whether or not this animal has dispersed.
		private bool mvarIsIndependent;
        // EER: a string indicating this animal's infection history from their animal attributes: Never_infected, Infected_died, Infected_recovered.
        //private string mvarNaturalImmunity;
        // a list of infections that the animal may have
        private cInfectionList mvarInfections;
		// a list of vaccines that have been given to the animal
		private cVaccineList mvarVaccines;
		// the year the animal died
		private int mvarYearDied;
		// the week the animal died
		private int mvarWeekDied;
		// a marker automatically passed from Mother to offspring
		private string mvarAutoMarker;
		// a marker passed from Mother (or Father) to offspring by subclasses
		private string mvarMarker;
		// a holder for mating partner's marker
		private string mvarPartnerMarker;
		// a flag indicating that this animal cannot give birth
		private int mvarCannotGiveBirth;
        // the list index position of this animal when it is loaded or saved (not updated during run!!)
        private int mvarListIndex;
        //YM
        // the value of the reproduction week
        private int mvarReproductionWeek;
        // the value of the reproduction week
        private int mvarReproductionWeek2;
        // the value of the reproduction week
        private int mvarReproductionWeek3;
        // the value of the mating week
        private int mvarMatingWeek;
        // the value of the mating week
        private int mvarMatingWeek2;
        // the value of the mating week
        private int mvarMatingWeek3;
        // the flag indicating that the animal mated //YM
        private bool mvarHasMated;
        // the flag indicating that the animal will die in the current week //YM
        private bool mvarWillDie;



        // Spawn babies.  This function calls the two abstract functions, GetNBabies and
        // CreateBaby, to create a list of offspring for the animal.  This function
        // raises an exception if 1) it is a juvenile or 2) it is male.
        private void Spawn() 
		{
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: Spawn()");

            //Console.WriteLine("Spawn - mvarPartnerMarker : "+ mvarPartnerMarker);
            // male animals cannot give birth!!
            if (mvarGender == enumGender.male)
				throw new InvalidOperationException("Animal is male and cannot give birth.");
           
            // juvenile animals cannot give birth!!
            if (this.AgeClass == enumAgeClass.YoungOfTheYear) 
				throw new InvalidOperationException("Animal is Young of the Year and cannot give birth.");

            // if this animal does not have partner marker info, it cannot give birth because it has not mated  
            if (mvarPartnerMarker.Length == 0) {
                //Console.WriteLine("mvarPartnerMarker.Length == 0");
                return;
            }
           
            // get the number of new babies
            int NBabies = this.GetNBabies();
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: Spawn(): get the number of new babies, NBabies = " + NBabies);
            // get a reference to the main animal list
            cMasterAnimalList Animals = mvarBackground.Animals;
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: Spawn(): get a reference to the main animal list");
            cAnimal TheBaby;
			// loop, creating this number of babies.
			for (int i = 0; i < NBabies; i++) 
			{
				// create a new baby
				TheBaby = this.CreateBaby(Animals.GetNextID());
				// pass on the AutoMarker
				TheBaby.AutoMarker = mvarAutoMarker;
				// calculate new marker value
				TheBaby.Marker = CalculateMarker();
				// add it to the main list
				Animals.AddBaby(TheBaby);
				// add this baby to the offspring list
				mvarOffspringIDs.Add(TheBaby.ID);
			}
		}

		// Mate. This function calls the virtual function, FindMate, which
		// provide a promiscuous mating model.  FindMate may be overidden to
		// provide other mating models
		private void DoMating(int CurrentWeek, bool PreventIncest)
		{
            //System.Diagnostics.Debug.WriteLine("");
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: DoMating()");
            // male animals cannot mate (at least not in the way the model works!!)
            if (mvarGender == enumGender.male)
				throw new InvalidOperationException("Animal is male and cannot mate.");
			// Young of the Year animals cannot mate!!
			if (this.AgeClass == enumAgeClass.YoungOfTheYear) 
				throw new InvalidOperationException("Animal is Young of the Year and cannot mate.");
			// clear out genetic marker of mate
			mvarPartnerMarker = "";
			// get the animal's mate
			cAnimal MyMate = FindMate(CurrentWeek, PreventIncest);
			// if a mate was found, proceed
			if (MyMate != null) {
				// raise an exception if the chosen mate is not of the same type
				if (MyMate.GetType().Name != this.GetType().Name)
					throw new InvalidOperationException("Animals are not of the same type.  Mating cannot occur.");
				// raise an exception if the mate is not a male
				if (MyMate.Gender != enumGender.male)
					throw new InvalidOperationException("Mate is not male.  Mating cannot occur.");
				// raise an exception if gentic material does not properly compare
				if (!CompareMarkers(MyMate)) 
					throw new InvalidOperationException("Genetic markers are not compatible.  Mating cannot occur.");
				// now swap gentic material
				mvarPartnerMarker = MyMate.Marker;
                //YM: 
                // TRUE if the animal has mated
                this.HasMated = true;

            }
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: DoMating() END");
        }


		// determine if disease will spread to a neibouring cell.
		// return true if disease should spread, false otherwise
		private bool CanSpreadDiseaseToNeighbour(cCell TheCell)
		{
			// if the passed cell is null, leave now
			if (TheCell == null) return false;
			// set up random number generator
			//mvarBackground.RandomNum.MinValue = 0;
			//mvarBackground.RandomNum.MaxValue = 100;
			// if the cell is in a different supercell, we must first apply in and out resistance tests
			if (TheCell.SuperCell.ID != this.CurrentCell.SuperCell.ID) {
				// check the out resistance for the animal's cell.  If it fails, exit now
				if (this.CurrentCell.SuperCell.OutResistance > 0) {
					if (mvarBackground.RandomNum.IntValue(1, 100) <= this.CurrentCell.SuperCell.OutResistance) return false;
				}
				// check the in resistance for the neighbouring cell.  If it fails, exit now
				if (TheCell.SuperCell.InResistance > 0) {
					if (mvarBackground.RandomNum.IntValue(1, 100) < TheCell.SuperCell.InResistance) return false;
				}
			}
			return true;
		}

		// spread a disease to the animals in a cell
		private void SpreadDiseaseToNeighbour(cCell TheCell, cDisease TheDisease, double ContactRate)
		{
			// set up random number generator
			// loop through all animals in the neighbouring cell, potentially infecting each one
			foreach (cAnimal Animal in TheCell.Animals) {
                double RanNum = mvarBackground.RandomNum.RealValue(0, 100);
				if (RanNum < ContactRate) Animal.Infect(TheDisease, this);
			}
		}

		// retrieve markers into an arraylist
		// a list of GeneticMarker objects is returned
		private GeneticMarker[] RetrieveMarkers(string MarkerList)
		{            
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: RetrieveMarkers()");

            // split on the semi-colon
            string delimStr = ";";
			char[] delimiter = delimStr.ToCharArray();
			// split out my markers on semicolon
            MarkerList = MarkerList.Trim();
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: RetrieveMarkers(): MarkerList = " + MarkerList);
            string[] Markers = MarkerList.Split(delimiter);
            // create arrays of markers
            GeneticMarker[] TheMarkers = new GeneticMarker[Markers.Length];
			// loop through all of my markers, creating a list
			for (int i=0; i<Markers.Length; i++) {
				GeneticMarker gm = new GeneticMarker();
				try {
					gm.parseValues(Markers[i]);
				}
				catch (InvalidOperationException ex) {
					throw new InvalidOperationException("Error occured parsing marker information.", ex);
				}
				TheMarkers[i] = gm;
			}
            //System.Diagnostics.Debug.WriteLine("cAnimal.cs: RetrieveMarkers(): Got TheMarkers");
            return TheMarkers;
		}


		// throw an exception indicating a zero length ID value
		private void ThrowIDException()
		{
			throw new ArgumentException("The ID of the animal must not be zero length.", "ID");
		}
		// throw an exception indicating a null background
		private void ThrowNullBackgroundException()
		{
			throw new ArgumentNullException("Background", "The background cannot be null.");
		}
		// throw an exception indicating that the animal is still alive
		private void ThrowIsAliveException()
		{
			throw new InvalidOperationException("The animal is still alive.");
		}

		// raise the AnimalInfected method
		private void RaiseAnimalInfected(cInfection TheInfection)
		{
			// prepare the arguments for the event
			cAnimalInfectedEventArgs e = new cAnimalInfectedEventArgs(this, TheInfection);
			// raise the event by invoking the delegate
			if (AnimalInfected != null) AnimalInfected(this, e);
		}

		// ********************* Events ***********************************************
		/// <summary>
		///		An animal infected event.  This is raised when an animal is infected by a disease.
		///		A reference to the animal and the infection object are passed as parameters.
		/// </summary>
		public event AnimalInfectedEventHandler AnimalInfected;

		/// <summary>
		///		A private class to hold parsed genetic codes.  Used internally by cAnimal when
		///		passing genetic information from mother and father to offspring.
		/// </summary>
		private class GeneticMarker 
		{
			// values for a genetic marker
			public string Name;
			public string Value1;
			public string Value2;

			// parse values from a string
			public void parseValues(string Values) 
			{                
                //System.Diagnostics.Debug.WriteLine("cAnimal.cs: GeneticMarker private class: parseValues()");
                //System.Diagnostics.Debug.WriteLine("cAnimal.cs: GeneticMarker private class: parseValues(): Values = " + Values);

                // split on the full colon
                string delimStr = ":";
				char[] delimiter = delimStr.ToCharArray();
				string[] ValueList = Values.Split(delimiter);
				// must be three value in this list
				if (ValueList.GetUpperBound(0) != 2) 
					throw new InvalidOperationException(String.Format("Genetic marker must contain a name and two values.  The passed string contains {0} items.", ValueList.GetUpperBound(0) + 1));
				// OK get the values
				Name = ValueList[0];
				Value1 = ValueList[1];
				Value2 = ValueList[2];
                //System.Diagnostics.Debug.WriteLine("cAnimal.cs: GeneticMarker private class: parseValues(): completed");
            }
		}
	}
}