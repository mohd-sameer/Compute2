using System;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using RngStreams;
using Random;
using System.IO;

namespace IndexedHashTable
{
    /// <summary>
    ///    A hashtable class that gives access to a list of items by integer index or by key.
    ///    Thus, the class behaves as a hashtable or as an array.  Items are ordered in
    ///    the order in which they are placed in the list unless the InsertAt method is
    ///    used.  The order of the items in the list may be randomly scrambled with the 
    ///    ScrambleOrder method.
    /// </summary>
    public class cIndexedHashTable :  IEnumerable
    {

        #region Constructor

        // ******************** Constructors *******************************************
        /// <summary>
        ///		The default constructor.
        /// </summary>
        public cIndexedHashTable(cUniformRandom ScrambleRnd)
		{
			// build an array list of keys.  This is how we keep things in numeric order
			KeysByIndex = new List<string>(); 
			Values = new Hashtable();
			// a counter for generating unique key values if user adds an item without
			// specifying a key value.
			AddNum = 0;
			mvarScrambleRandom = ScrambleRnd;
        }

        #endregion

        #region Public Properties
        // ************************ properties ******************************************
		/// <summary>
		///		Get or set the value of an item in the table indexed by its numeric index.  If
		///		Index is less than zero or greater than the number of items in the list minus
		///		one, an ArgumentOutOfRangeException exception is raised.
		/// </summary>
		// No need to check for index out of range.  The KeysByIndex arraylist will do this for
		// us
		public object this[int Index]
		{
			get
			{
				// return value at this index
                return Values[KeysByIndex[Index]];
			}
			set
			{
				// set the value at this index
                Values[KeysByIndex[Index]] = value;
			}
		}

		/// <summary>
		///		Get or set the value of an item in the table indexed by its key value.  If key
		///		is not found in the table, an ArgumentException exception is raised.
		/// </summary>
		public object this[string key]
		{
			get
			{
				// return the object with this key
				return Values[key];
			}
			set
			{
				// set the value with this key
				Values[key] = value;
			}
		}

		/// <summary>
		///Get the number of items in the list 
		/// </summary>
		public int Count
		{
			get
			{
				return Values.Count;
			}
		}
		
        #endregion

        #region Public Methods

        // ************************* methods *****************************************
		/// <summary>
		///		Add an item to the end of the table with the given key value.
		/// </summary>
		/// <param name="key">
		///		The key value of the item.  An ArgumentNullException exception is raised if
		///		key is null.  An ArgumentException exception is raised if the key already
		///		exists in the collection.
		///	</param>
		/// <param name="item">The item being added to the table.</param>
		public void Add(string key, object item)
		{
			// add value to Values list
			Values.Add(key, item);
			// add key to list of keys
			KeysByIndex.Add(key);
		}

		/// <summary>
		///		Add an item to the end of the table.  A unique key value is automatically
		///		created for the item.  This key value will take the form 
		///		"cIndexedHashTable_Key_XXXX" (where XXXX is a number from 1 to 2^63).
		/// </summary>
		/// <param name="item">The item being added to the table.</param>
		/// <returns>The position of the item in the table (0 based).</returns>
		public int Add(object item)
		{
			// get a key for the new item
			// this must be unique and is generated by the AddNum private variable
			StringBuilder key = new StringBuilder("cIndexedHashTable_Key_");
			key.Append(AddNum++);
			// add the item to the list
			Add(key.ToString(), item);
			// return the items position
			return Values.Count - 1;
		}

		/// <summary>
		///		Insert an item into the table at a given position.  A unique key value
		///		is automatically created for the item.  This key value will take the form 
		///		"cIndexedHashTable_Key_XXXX" (where XXXX is a number from 1 to 2^63).
		/// </summary>
		/// <param name="position">
		///		The position of the item in the table (0 based).  An ArgumentOutOfRangeException
		///		exception is raised if position is less than zero or greater than the number of
		///		items in the list minus one.
		///	</param>
		/// <param name="item">The item being added to the table.</param>
		public void Insert(int position, object item) 
		{
			// get a key for the new item
			// this must be unique and is generated by the AddNum private variable
			StringBuilder key = new StringBuilder("cIndexedHashTable_Key_");
			key.Append(AddNum++);
			// add key to list of keys.  Do this first in case it causes an exception.
			KeysByIndex.Insert(position, key.ToString());
			// add value to Values list
			Values.Add(key, item);
		}

		/// <summary>
		///		Insert an item into the table at a given position.
		/// </summary>
		/// <param name="position">
		///		The position of the item in the table (0 based).  An ArgumentOutOfRangeException
		///		exception is raised if position is less than zero or greater than the number of
		///		items in the list minus one.
		///	</param>
		/// <param name="key">
		///		The key value of the item.  An ArgumentNullException exception is raised if
		///		key is null.  An ArgumentException exception is raised if the key already
		///		exists in the collection.
		///	</param>
		/// <param name="item">The item being added to the table.</param>
		public void Insert(int position, string key, object item) 
		{
			// add key to list of keys.  Do this first in case it causes an exception.
			KeysByIndex.Insert(position, key);
			// add value to Values list
			try 
			{
				Values.Add(key, item);
			}
			catch (Exception) 
			{
				// if an error occurs here, remove the key value from the KeysByIndex list
				// and rethrow the exception.
				KeysByIndex.RemoveAt(position);
				throw;
			}
		}
		
		/// <summary>
		///Determine whether or not the list contains an item with the specified key 
		/// </summary>
		/// <param name="key">
		/// The key to search for
		/// </param>
		/// <returns>
		/// True if an item in the list has the key, false otherwise
		/// </returns>
		public bool ContainsKey(string key)
		{
			return Values.ContainsKey(key);
		}

		/// <summary>
		///		Remove all items from the table.
		/// </summary>
		public void Clear()
		{
			// clear Values hashtable and list of keys
			Values.Clear();
			KeysByIndex.Clear();
		}

		/// <summary>
		///		Get the key value of the item at the specified position.
		/// </summary>
		/// <param name="position">
		///		The position of the item in the table (0 based).  An ArgumentOutOfRangeException
		///		exception is raised if position is less than zero or greater than the number of
		///		items in the list minus one.
		///	</param>
		/// <returns></returns>
		public string GetKey(int position) 
		{
			return KeysByIndex[position];
		}

		/// <summary>
		///		Remove the item from the table with the given key value.
		/// </summary>
		/// <param name="key">
		///		The key value of the item to remove.  An ArgumentNullException exception is
		///		raised if key is null.
		/// </param>
		public void Remove(string key)
		{
			Values.Remove(key);
			KeysByIndex.Remove(key);
		}

		/// <summary>
		///		Remove the item from the table at the given index position.
		/// </summary>
		/// <param name="index">
		///		The index position of the item to remove. An ArgumentOutOfRangeException
		///		exception is raised if index is less than zero or greater than the number 
		///		of items in the list minus one.
		///	</param>
		public void RemoveAt(int index)
		{
			// make sure Index is in range
			if (index < 0 || index >= Values.Count) 	throw new ArgumentOutOfRangeException("index");
			// remove the value at this position
			object key = KeysByIndex[index];
			KeysByIndex.RemoveAt(index);
			Values.Remove(key);
		}

		/// <summary>
		///		Make a copy of this table.  The copy is a complete copy, not just a
		///		reference to the same table.  The same scramble random number generator
        ///		is used
		/// </summary>
		/// <returns>A reference to the copy.</returns>
		public object Clone()
		{
			cIndexedHashTable TheClone = new cIndexedHashTable(mvarScrambleRandom);
			for (int i = 0; i < Values.Count; i++) {
				TheClone.Add(KeysByIndex[i], this[i]);
			}
			return TheClone;
		}

		/// <summary>
		///		Copy all items in the table into an array.  Items are copied into the 
		///		array in their current order.
		/// </summary>
		/// <param name="theArray">
		///		The array receiving the items in the list.  It must be size appropriatly
		///		to hold all items in the table.  A RankException is raised if the array has
		///		more than one dimension.  An ArgumentException is raised if the array does
		///		not have enough elements to hold the contents of the list.
		///	</param>
		/// <param name="ArrayIndex">
		///		The position in the array of the first item in the list.  An
		///		ArgumentOutOfRangeException exception is raised if ArrayIndex is less than
		///		zero.
		///	</param>
		public void CopyTo(Array theArray, int ArrayIndex)
		{
			// make sure array is only one rank
			if (theArray.Rank > 1) 
				throw new RankException("Array passed to CopyTo can only be one-dimensional");
			// make sure ArrayIndex is > 0
			if (ArrayIndex < 0) 
				throw new ArgumentOutOfRangeException("ArrayIndex");
			// make sure we have enough space
			if (theArray.Length - ArrayIndex < Values.Count)
				throw new ArgumentException("Insufficient space in the array", "ArrayIndex");
			// copy values to the array
			for (int i = 0; i < Values.Count; i++) {
				theArray.SetValue(this[i], i + ArrayIndex);
			}
		}
		
		/// <summary>
		///		Returns the position of the passed item in the table.  NOTE: this
		///		function is relatively inefficient and should not be called repeatedly.
		/// </summary>
		/// <param name="item">The item to search for.</param>
		/// <returns>
		///		The position of the item in the table.  -1 is returned if the item is
		///		not found.
		/// </returns>
		public int IndexOf(object item) 
		{
			foreach (DictionaryEntry DE in Values)
			{
				// is this the value we are looking for
				if (item == DE.Value) {
					// YES: return the position of it's key 
					return KeysByIndex.IndexOf((string)DE.Key);
				}
			}
			return -1;
		}

		/// <summary>
		///		Scramble the order of the items in the list. This affects the order returned
		///		by integer index values and the enumerator.
		/// </summary>
		public void ScrambleOrder()
		{
			// only do this if two or more items are in the list
			if (Values.Count > 1 && mvarScrambleRandom != null)	
            {
				// we actually want to scramble the order of the items in the KeysByIndex
				// List.  There is no need to touch the main HashTable.
				string Temp;
				// loop through items in the list 
				for (int i = 0; i < Values.Count - 1; i++) {
                    // get a random integer between i + 1 and the end of the list
                    int ScramblePos = mvarScrambleRandom.IntValue(i + 1, Values.Count - 1);
					// swap the two Key values at the ith position and the random position
					Temp = KeysByIndex[i];
					KeysByIndex[i] = KeysByIndex[ScramblePos];
					KeysByIndex[ScramblePos] = Temp;
				}
			}
		}

		/// <summary>
		///		Sort the list by the key values.  This affects the order returned
		///		by integer index values and the enumerator.
		/// </summary>
		public void SortKeys()
		{
			// only do this if there are two or more items in the list
			if (Values.Count > 1) KeysByIndex.Sort();
		}

		/// <summary>
		///		Get an enumerator for the cIndexHashTable.
		/// </summary>
		/// <returns>The enumerator as an IEnumerator.</returns>
		public IEnumerator GetEnumerator()
		{
			// get an enumerator for the indexed hashtable
			for (int i=0; i<KeysByIndex.Count; i++) yield return Values[KeysByIndex[i]];
        }

		#endregion
		
        #region Private Methods and Values

        // ************************ private members **************************************

		// Array list to hold key values
		private List<string> KeysByIndex;
		private Hashtable Values;
		// the integer value for automatically keying items added to the list
		private long AddNum;
        //random numbers for scrambling the list
        private cUniformRandom mvarScrambleRandom;

        #endregion
    }


}